const express = require("express");
const router = express.Router();

const dayjs = require('dayjs');
const customParseFormat = require('dayjs/plugin/customParseFormat');
const isSameOrBefore = require('dayjs/plugin/isSameOrBefore');
const isSameOrAfter = require('dayjs/plugin/isSameOrAfter');
const duration = require('dayjs/plugin/duration');
const advancedFormat = require('dayjs/plugin/advancedFormat');
require('dayjs/locale/de')

dayjs.extend(advancedFormat);
dayjs.extend(duration);
dayjs.extend(isSameOrBefore)
dayjs.extend(isSameOrAfter)
dayjs.extend(customParseFormat);
dayjs.locale('de')

const roundUpToNearest30Mins = (time) => {
  const format = "HH:mm:ss";
  const parsedTime = dayjs(time, format);
  
  // Calculate total minutes
  let totalMinutes = parsedTime.hour() * 60 + parsedTime.minute();

  // Round up to the nearest 30 minutes
  totalMinutes = Math.ceil(totalMinutes / 30) * 30;

  // Adjust hour and minute
  const roundedHours = Math.floor(totalMinutes / 60);
  const roundedMinutes = totalMinutes % 60;

  // Format the result with seconds
  const result = dayjs().hour(roundedHours).minute(roundedMinutes).second(parsedTime.second()).format(format);
  return result;
}

const getServiceDuration = (durationTime, bufferTime) => {
  if (!bufferTime) return durationTime;

  const format = "HH:mm:ss";
  const parsedTime1 = dayjs(durationTime, format);
  const parsedTime2 = dayjs(bufferTime, format);

  // Add the times together
  const totalTime = parsedTime1.add(parsedTime2.hour(), 'hour').add(parsedTime2.minute(), 'minute').add(parsedTime2.second(), 'second');

  return totalTime.format(format);
}

const getAppointmentEndTime = (startTime, serviceDuration) => {
  const format = "HH:mm:ss";
  const parsedStartTime = dayjs(startTime, format);
  const parsedServiceDuration = dayjs(serviceDuration, format);

  // Add the times together
  const endTime = parsedStartTime.add(parsedServiceDuration.hour(), 'hour').add(parsedServiceDuration.minute(), 'minute').add(parsedServiceDuration.second(), 'second');

  return roundUpToNearest30Mins(endTime)
  // return endTime.format(format);
}

module.exports = (db) => {
  router.get("/:date/:serviceId", async (req, res) => {
    try {
      const paramDate = req.params.date;
      const serviceId = req.params.serviceId;

      // get Timeslots from the database
      const timeSlotsQuery = 'SELECT timeslot_id, start_time, end_time FROM TimeSlots';
      const [timeSlotsRows] = await db.promise().query(timeSlotsQuery);
      const timeSlots = timeSlotsRows.map((row) => ({
        timeslotId: row.timeslot_id,
        startTime: row.start_time,
        endTime: row.end_time,
      }));

      // get Service from the database
      const serviceQuery = 'SELECT * FROM Services WHERE id = ?';
      const [serviceRows] = await db.promise().query(serviceQuery, [serviceId]);

      //get service duration (service_time + buffer_time)
      const serviceDurationAndBufferTimeInMinutes = getServiceDuration(serviceRows[0].duration_time, serviceRows[0].buffer_time);

      // get EmployeeAvailability from the database
      const employeeAvailabilityQuery = `SELECT DISTINCT employee_id, day_id, start_time_id, end_time_id FROM EmployeeAvailability`;
      const [employeeAvailabilityRows] = await db.promise().query(employeeAvailabilityQuery);
      const employeeAvailability = employeeAvailabilityRows.map(row => ({
        employeeId: row.employee_id,
        dayId: row.day_id,
        startTimeId: row.start_time_id,
        endTimeId: row.end_time_id
      }));

      const addTimeSlotsAccordingEmployeeAvailability = (employeeStartTimeId, employeeEndTimeId) => {
        // timeSlots == all available time slots from data base
        // employeeStartTimeId and employeeEndTimeId are the start and end time of the employee's availability
        // return all time slots that are within the employee's availability
        return timeSlots.filter((timeslot) => {
          return timeslot.timeslotId >= employeeStartTimeId && timeslot.timeslotId <= employeeEndTimeId;
        });
      }

      const findBlockedTimeSlots = async (availableTimeslots, date) => {
        let updatedTimeslots = [...availableTimeslots];
        console.log(updatedTimeslots);

        // Define the date for which you want to check appointments
        const targetDate = date;

        // Query MySQL to get all entries for the target date
        const savedAppointmentsQuery = `SELECT * FROM SavedAppointments WHERE date = ?`;
        const [results] = await db.promise().query(savedAppointmentsQuery, [targetDate]);

        // Iterate over the results and identify occupied timeslots
        results.forEach(appointment => {
          const rangeStartTime = dayjs(appointment.time, 'HH:mm:ss');
          const rangeEndTime = dayjs(getAppointmentEndTime(appointment.time, appointment.service_duration), 'HH:mm:ss');

          updatedTimeslots = updatedTimeslots.filter((timeslot) => {
            const slotStartTime = dayjs(timeslot.startTime, 'HH:mm:ss');
            const slotEndTime = dayjs(timeslot.endTime, 'HH:mm:ss');
            
            // Check if timeslot falls outside the specified range
            return slotStartTime.isSameOrAfter(rangeEndTime) || slotEndTime.isSameOrBefore(rangeStartTime);
          });
        });

        return updatedTimeslots;
      };

      const filterTimeSlots = (availableTimeslots) => {
        const filteredAvailableTimeSlots = availableTimeslots.filter((availableTimeslot) => {
        return availableTimeslots.some(slot => slot.endTime === getAppointmentEndTime(availableTimeslot.startTime, serviceDurationAndBufferTimeInMinutes))
        })
    
        return filteredAvailableTimeSlots;
      };
      
      // Iterate through all employeeAvailability from the database
      const dateObj = dayjs(paramDate, { format: "YYYY-MM-DD" });
      const today = dayjs().startOf('day');
      const firstDayOfMonth = dateObj.startOf('month');
      const lastDayOfMonth = dateObj.endOf('month');
      const availableDays = [];

      for (const availability of employeeAvailability) {
        let currentDay = firstDayOfMonth;

        // Iterate through the days of the month for each row
        while (currentDay.isBefore(lastDayOfMonth) || currentDay.isSame(lastDayOfMonth, 'day')) {
          // Check if the day is in the future (excluding today)
          if (currentDay.isAfter(today) && currentDay.day() === availability.dayId) {
            let availableTimeslots = addTimeSlotsAccordingEmployeeAvailability(availability.startTimeId, availability.endTimeId);
            availableTimeslots = await findBlockedTimeSlots(availableTimeslots, currentDay.format('YYYY-MM-DD'));
            availableTimeslots = filterTimeSlots(availableTimeslots);

            availableDays.push(
              { 
                day: currentDay.format('YYYY-MM-DD'),
                employeeId: availability.employeeId,
                startTimeId: availability.startTimeId,
                endTimeId: availability.endTimeId,
                availableTimeslots,
              }
            );
          }
          currentDay = currentDay.add(1, 'day');
        }
      }

      res.json(availableDays);
    } catch (error) {
      console.error('Error:', error);
      res.status(500).json({ error: "Internal Server Error" });
    }
  });

  return router;
};


// Function to calculate end time based on start time and duration
function calculateEndTime(startTime, duration) {
  const [hours, minutes, seconds] = startTime.split(':').map(Number);
  const totalMinutes = hours * 60 + minutes + duration;
  const endHours = Math.floor(totalMinutes / 60);
  const endMinutes = totalMinutes % 60;
  return `${endHours.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}:${seconds}`;
}
